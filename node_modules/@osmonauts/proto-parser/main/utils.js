"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lookupSymbolScopes = exports.instanceType = exports.getTypes = exports.getServices = exports.getPackageAndNestedFromStr = exports.getObjectName = exports.getNestedProtoGeneric = exports.getNestedProto = exports.getNested = exports.getEnums = exports.NATIVE_TYPES = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _dotty = _interopRequireDefault(require("dotty"));

var _protobufjs = require("@pyramation/protobufjs");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var getNestedProto = function getNestedProto(root) {
  var nestedPath = 'root.nested.' + root["package"].split('.').join('.nested.') + '.nested';
  return _dotty["default"].get(root, nestedPath);
};

exports.getNestedProto = getNestedProto;

var getNestedProtoGeneric = function getNestedProtoGeneric(root, path) {
  path = root["package"].split('.').concat(path);
  var nestedPath = 'root.nested.' + path.join('.nested.') + '.nested';
  return _dotty["default"].get(root, nestedPath);
};

exports.getNestedProtoGeneric = getNestedProtoGeneric;

var getNested = function getNested(root, path) {
  var nestedPath = 'root.nested.' + path.join('.nested.') + '.nested';
  return _dotty["default"].get(root, nestedPath);
}; // https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.cc#L3798-L3812


exports.getNested = getNested;

var lookupSymbolScopes = function lookupSymbolScopes(name, relativeTo, list) {
  // fully-qualified name
  if (name.startsWith('.')) return [name.replace(/^\./, '')];
  if (!list) list = [];
  var relativeToParts = relativeTo.split('.'); // This first searches siblings of relative_to (pop off relative_to)

  relativeToParts.pop();
  var newName = [].concat((0, _toConsumableArray2["default"])(relativeToParts), (0, _toConsumableArray2["default"])(name.split('.'))).join('.');
  if (newName === name) return [].concat((0, _toConsumableArray2["default"])(list), [name]);
  return lookupSymbolScopes(name, relativeToParts.join('.'), [].concat((0, _toConsumableArray2["default"])(list), [newName]));
};

exports.lookupSymbolScopes = lookupSymbolScopes;

var getPackageAndNestedFromStr = function getPackageAndNestedFromStr(type, pkg) {
  if (type.startsWith(pkg) && type.length > pkg.length) {
    var nested = type.substring(pkg.length + 1);
    return {
      nested: nested,
      "package": pkg
    };
  }
};

exports.getPackageAndNestedFromStr = getPackageAndNestedFromStr;

var getServices = function getServices(root) {
  var nested = getNestedProto(root);
  return Object.keys(nested).map(function (key) {
    return nested[key];
  }).filter(function (obj) {
    return obj instanceof _protobufjs.Service;
  }).map(function (el) {
    return _objectSpread({
      name: el.name
    }, el.toJSON({
      keepComments: true
    }));
  });
};

exports.getServices = getServices;

var getTypes = function getTypes(root) {
  var nested = getNestedProto(root);
  return Object.keys(nested).map(function (key) {
    return nested[key];
  }).filter(function (obj) {
    return obj instanceof _protobufjs.Type;
  }).map(function (el) {
    return _objectSpread({
      name: el.name
    }, el.toJSON({
      keepComments: true
    }));
  });
};

exports.getTypes = getTypes;

var getEnums = function getEnums(root) {
  var nested = getNestedProto(root);
  return Object.keys(nested).map(function (key) {
    return nested[key];
  }).filter(function (obj) {
    return obj instanceof _protobufjs.Enum;
  }).map(function (el) {
    return _objectSpread({
      name: el.name
    }, el.toJSON({
      keepComments: true
    }));
  });
};
/*
    nested objects get a slightly different naming convention
    e.g. SignatureDescriptor_Data or SignatureDescriptor_Data_Multi
*/


exports.getEnums = getEnums;

var getObjectName = function getObjectName(name) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!scope.length || scope.length === 1) return name;

  var _scope = (0, _toArray2["default"])(scope),
      _pkg = _scope[0],
      scopes = _scope.slice(1);

  return [].concat((0, _toConsumableArray2["default"])(scopes), [name]).join('_');
};

exports.getObjectName = getObjectName;
var NATIVE_TYPES = ["double", // 0
"float", // 1
"int32", // 2
"uint32", // 3
"sint32", // 4
"fixed32", // 5
"sfixed32", // 6
"int64", // 7
"uint64", // 8
"sint64", // 9
"fixed64", // 10
"sfixed64", // 11
"bool", // 12
"string", // 13
"bytes" // 14
];
exports.NATIVE_TYPES = NATIVE_TYPES;

var instanceType = function instanceType(obj) {
  if (obj instanceof _protobufjs.Type) {
    return {
      name: obj.name,
      type: 'Type'
    };
  }

  if (obj instanceof _protobufjs.Enum) {
    return {
      name: obj.name,
      type: 'Enum'
    };
  }

  if (obj instanceof _protobufjs.Service) {
    return {
      name: obj.name,
      type: 'Service'
    };
  }

  if (obj instanceof _protobufjs.Root) {
    return {
      type: 'Root'
    };
  }

  if (obj instanceof _protobufjs.Namespace) {
    return {
      type: 'Namespace'
    };
  } // if (obj.name === 'Timestamp') {
  //     return {
  //         name: obj.name,
  //         type: 'google'
  //     };
  // }
  // if (obj.name === 'Duration') {
  //     return {
  //         name: obj.name,
  //         type: 'google'
  //     };
  // }


  if (obj.name.match(/^[a-z]/)) {
    throw new Error('instanceType() cannot find protobufjs Type');
  } // duck typing... 
  // TODO why did we lose instance types/names?


  if (obj.fields) {
    return {
      name: obj.name,
      type: 'Type'
    };
  }

  if (obj.values) {
    return {
      name: obj.name,
      type: 'Enum'
    };
  }

  throw new Error('instanceType() cannot find protobufjs Type');
};

exports.instanceType = instanceType;