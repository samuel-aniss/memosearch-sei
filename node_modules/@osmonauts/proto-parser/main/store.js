"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseProto = exports.ProtoStore = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _glob = require("glob");

var _protobufjs = require("@pyramation/protobufjs");

var _fs = require("fs");

var _path = require("path");

var _utils = require("./utils");

var _traverse = require("./traverse");

var _lookup = require("./lookup");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var parseProto = function parseProto(content) {
  return (0, _protobufjs.parse)(content, {
    // we need to update this
    keepCase: false,
    alternateCommentMode: true,
    preferTrailingComment: false
  });
};

exports.parseProto = parseProto;

var ProtoStore = /*#__PURE__*/function () {
  function ProtoStore() {
    var protoDirs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    (0, _classCallCheck2["default"])(this, ProtoStore);
    (0, _defineProperty2["default"])(this, "files", void 0);
    (0, _defineProperty2["default"])(this, "protoDirs", void 0);
    (0, _defineProperty2["default"])(this, "deps", void 0);
    (0, _defineProperty2["default"])(this, "protos", void 0);
    (0, _defineProperty2["default"])(this, "packages", void 0);
    (0, _defineProperty2["default"])(this, "_traversed", false);
    this.protoDirs = protoDirs.map(function (protoDir) {
      return (0, _path.resolve)(protoDir);
    });
  }

  (0, _createClass2["default"])(ProtoStore, [{
    key: "findProto",
    value: function findProto(filename) {
      return this.getProtos().find(function (proto) {
        return proto.filename === filename;
      });
    }
  }, {
    key: "findProtoWhere",
    value: function findProtoWhere(fn) {
      return this.getProtos().find(function (ref) {
        return fn(ref);
      });
    }
  }, {
    key: "filterProtoWhere",
    value: function filterProtoWhere(fn) {
      return this.getProtos().filter(function (ref) {
        return fn(ref);
      });
    }
  }, {
    key: "findProtoObject",
    value: function findProtoObject(filename, name) {
      var _proto$traversed;

      var proto = this.findProto(filename);
      return (0, _utils.getNestedProto)((_proto$traversed = proto.traversed) !== null && _proto$traversed !== void 0 ? _proto$traversed : proto.proto)[name];
    }
  }, {
    key: "getProtos",
    value: function getProtos() {
      if (this.protos) return this.protos;
      var contents = this.protoDirs.reduce(function (m, protoDir) {
        var protoSplat = (0, _path.join)(protoDir, '/**/*.proto');
        var protoFiles = (0, _glob.sync)(protoSplat);
        var contents = protoFiles.map(function (filename) {
          return {
            absolute: filename,
            filename: filename.split(protoDir)[1].replace(/^\//, ''),
            content: (0, _fs.readFileSync)(filename, 'utf-8')
          };
        });
        return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(contents));
      }, []);
      var protos = contents.map(function (_ref) {
        var absolute = _ref.absolute,
            filename = _ref.filename,
            content = _ref.content;

        try {
          var proto = parseProto(content);
          return {
            absolute: absolute,
            filename: filename,
            proto: proto
          };
        } catch (e) {
          console.error("".concat(filename, " has a proto syntax error"));
          throw e;
        }
      });
      this.protos = protos;
      return protos;
    }
  }, {
    key: "getPackages",
    value: function getPackages() {
      if (this.packages) return this.packages;
      this.packages = this.getProtos().reduce(function (m, ref) {
        return (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(m), [ref.proto["package"]])));
      }, []); // LONGEST strings first, for better matching

      this.packages = this.packages.sort(function (a, b) {
        return b.length - a.length;
      });
      return this.packages;
    }
  }, {
    key: "parseScope",
    value: function parseScope(type) {
      var pkgs = this.getPackages();

      var _iterator = _createForOfIteratorHelper(pkgs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pkg = _step.value;
          var found = (0, _utils.getPackageAndNestedFromStr)(type, pkg);
          if (found) return found;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "getDeps",
    value: function getDeps() {
      if (this.deps) return this.deps;
      var deps = this.getProtos().map(function (el) {
        var filename = el.filename,
            _el$proto = el.proto,
            pkg = _el$proto["package"],
            imports = _el$proto.imports;
        return {
          filename: filename,
          "package": pkg,
          imports: imports
        };
      });
      this.deps = deps;
      return deps;
    }
  }, {
    key: "traverseAll",
    value: function traverseAll() {
      var _this = this;

      if (this._traversed) return;
      this.protos = this.getProtos().map(function (ref) {
        return {
          absolute: ref.absolute,
          filename: ref.filename,
          proto: ref.proto,
          traversed: (0, _traverse.traverse)(_this, ref)
        };
      });
      this._traversed = true;
    }
  }, {
    key: "get",
    value: function get(from, name) {
      if (!this._traversed) throw new Error('get() requires traversal');
      return (0, _lookup.lookupAny)(this, from, name);
    }
  }]);
  return ProtoStore;
}();

exports.ProtoStore = ProtoStore;