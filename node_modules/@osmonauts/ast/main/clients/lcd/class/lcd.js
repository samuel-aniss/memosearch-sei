"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTemplateTag = exports.getUrlTemplateString = exports.createLCDClient = exports.createAggregatedLCDClient = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _utils = require("../../../utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var returnReponseType = function returnReponseType(ResponseType) {
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(ResponseType))])));
};

var firstLower = function firstLower(s) {
  return s = s.charAt(0).toLowerCase() + s.slice(1);
};

var firstUpper = function firstUpper(s) {
  return s = s.charAt(0).toUpperCase() + s.slice(1);
};

var returnAwaitRequest = function returnAwaitRequest() {
  var hasOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var args = [t.identifier('endpoint')];

  if (hasOptions) {
    args.push(t.identifier('options'));
  }

  return t.returnStatement(t.awaitExpression(t.callExpression(t.memberExpression(t.thisExpression(), t.identifier('request')), args)));
};

var makeOptionsObject = function makeOptionsObject() {
  return t.variableDeclaration('const', [t.variableDeclarator((0, _utils.identifier)('options', t.tsTypeAnnotation(t.tsAnyKeyword())), t.objectExpression([t.objectProperty(t.identifier('params'), t.objectExpression([]))]))]);
};

var setParamOption = function setParamOption(name) {
  return t.ifStatement(t.binaryExpression('!==', t.unaryExpression('typeof', t.optionalMemberExpression(t.identifier('params'), t.identifier(name), false, true)), t.stringLiteral('undefined')), t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.memberExpression(t.identifier('options'), t.identifier('params')), t.identifier((0, _case.snake)(name))), t.memberExpression(t.identifier('params'), t.identifier(name))))]));
}; // breaks a url string to prepare it for template strings


var getUrlTemplateString = function getUrlTemplateString(url) {
  var parts = url.split('/').filter(function (a) {
    return a !== '';
  });
  var cur = [];
  var strs = [];
  var atEnd = false;

  for (var p = 0; p < parts.length; p++) {
    var part = parts[p];

    if (/[{}]+/.test(part)) {
      if (p === parts.length - 1) atEnd = true;

      if (cur.length) {
        var vals = cur.join('/');
        strs.push(vals);
      } else {
        strs.push('/');
      }

      cur = [];
    } else {
      cur.push(part);
    }
  }

  if (cur.length) {
    strs.push(cur.join('/'));
  }

  strs = strs.filter(function (str) {
    return str !== '';
  }).map(function (v, i) {
    if (i === 0) {
      if (!v.endsWith('/')) v = "".concat(v, "/");
      return v;
    } else if (i === strs.length - 1) {
      if (atEnd) {
        // we want them to end with / if it's an "atEnd" el
        if (!v.endsWith('/')) v = "".concat(v, "/");
        return v;
      } // they should all start with "/"


      if (!v.startsWith('/')) v = "/".concat(v);
      return v;
    }

    if (!v.endsWith('/')) v = "".concat(v, "/");
    if (!v.startsWith('/')) v = "/".concat(v);
    return v;
  });
  return {
    strs: strs,
    atEnd: atEnd
  };
}; // do we need to set end prop in ast?
// we may want to t.templateElement!!!


exports.getUrlTemplateString = getUrlTemplateString;

var makeTemplateTag = function makeTemplateTag(info) {
  if (!info.url) throw new Error('no URL on service method');
  var parts = getUrlTemplateString(info.url);
  var templateElts = parts.strs.map(function (raw) {
    return t.templateElement({
      raw: raw
    });
  }); // Number of TemplateLiteral quasis should be exactly one more than the number of expressions

  var pathParams = info.pathParams.map(function (param) {
    return t.memberExpression(t.identifier('params'), t.identifier(param));
  });

  if (parts.atEnd) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  } // THIS MEANS WE PROBABLY HAVE A BUG


  if (templateElts.length !== pathParams.length + 1) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  }

  templateElts.forEach(function (el, n) {
    if (n === templateElts.length - 1) {
      // remove trailing slash...
      el.value.raw = el.value.raw.replace(/\/$/, '');
    }
  });
  return t.templateLiteral(templateElts, pathParams);
};

exports.makeTemplateTag = makeTemplateTag;

var makeComment = function makeComment(comment) {
  return [{
    type: 'CommentBlock',
    value: " ".concat(comment, " ")
  }];
};

var requestMethod = function requestMethod(context, serviceMethod) {
  var _serviceMethod$commen, _serviceMethod$fields;

  var methodName = firstLower(serviceMethod.name);
  var comment = (_serviceMethod$commen = serviceMethod.comment) !== null && _serviceMethod$commen !== void 0 ? _serviceMethod$commen : serviceMethod.name;

  if (!serviceMethod.info) {
    throw new Error('No Service URL!');
  }

  var queryParams = serviceMethod.info.queryParams.map(function (param) {
    return setParamOption(param);
  });
  var optionsAst = [];

  if (serviceMethod.info.queryParams.length) {
    // options params object
    optionsAst.push(makeOptionsObject());
  } // parse field types


  Object.entries((_serviceMethod$fields = serviceMethod.fields) !== null && _serviceMethod$fields !== void 0 ? _serviceMethod$fields : {}).map(function (_ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    switch (value.parsedType.type) {
      case 'Type':
        // this gets the import for us
        // if later we need to get subtypes, we have it all w/ctx
        context.getTypeName(value);

      case 'native':
    }
  });
  return (0, _utils.classMethod)('method', t.identifier(methodName), [(0, _utils.identifier)('params', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(serviceMethod.requestType))))], t.blockStatement([].concat(optionsAst, (0, _toConsumableArray2["default"])(queryParams), [// endpoint
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('endpoint'), makeTemplateTag(serviceMethod.info))]), // return 
  returnAwaitRequest(serviceMethod.info.queryParams.length > 0)])), returnReponseType(serviceMethod.responseType), makeComment(comment), false, false, false, true // async
  );
};

var createLCDClientClassBody = function createLCDClientClassBody(clientName, methods) {
  return t.exportNamedDeclaration(t.classDeclaration(t.identifier(clientName), t.identifier('LCDClient'), t.classBody([// constructor
  t.classMethod('constructor', t.identifier('constructor'), [t.objectPattern([t.objectProperty(t.identifier('restEndpoint'), t.identifier('restEndpoint'), false, true)])], t.blockStatement([t.expressionStatement(t.callExpression(t["super"](), [t.objectExpression([t.objectProperty(t.identifier('restEndpoint'), t.identifier('restEndpoint'), false, true)])]))]))].concat((0, _toConsumableArray2["default"])(methods)))));
};

var createLCDClient = function createLCDClient(context, service) {
  context.addUtil('LCDClient');
  var methods = Object.keys(service.methods).map(function (key) {
    var method = service.methods[key];
    if (method.info) return requestMethod(context, method);
  }).filter(Boolean);

  if (methods.length) {
    var clientName = 'LCD' + firstUpper(service.name) + 'Client';
    return createLCDClientClassBody(clientName, methods);
  }
};

exports.createLCDClient = createLCDClient;

var createAggregatedLCDClient = function createAggregatedLCDClient(context, services, clientName) {
  context.addUtil('LCDClient');
  var methods = services.reduce(function (m, service) {
    var innerMethods = Object.keys(service.methods).map(function (key) {
      var method = service.methods[key];
      return requestMethod(context, method);
    });
    return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(innerMethods));
  }, []);
  return createLCDClientClassBody(clientName, methods);
};

exports.createAggregatedLCDClient = createAggregatedLCDClient;