"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRpcInterface = exports.createRpcClientInterface = exports.createRpcClientClass = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../../../utils");

var _utils2 = require("@osmonauts/utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var rpcMethod = function rpcMethod(name, request, response, trailingComments, leadingComments) {
  return (0, _utils.tsMethodSignature)(t.identifier(name), null, [(0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(request))))], t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(response))]))), trailingComments, // seemingly not working?
  leadingComments);
}; // this.Accounts = this.Accounts.bind(this);


var bindThis = function bindThis(name) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [t.thisExpression()])));
}; // const data = QueryAccountsRequest.encode(request).finish();


var encodeData = function encodeData(name) {
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier('data'), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(name), t.identifier('encode')), [t.identifier('request')]), t.identifier('finish')), []))]);
}; // const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);


var promiseRequest = function promiseRequest(name, packageImportName) {
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier('promise'), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('rpc')), t.identifier('request')), [t.stringLiteral(packageImportName), t.stringLiteral(name), t.identifier('data')]))]);
}; // return promise.then((data) => QueryAccountsResponse.decode(new _m0.Reader(data)));


var returnPromise = function returnPromise(name) {
  return t.returnStatement(t.callExpression(t.memberExpression(t.identifier('promise'), t.identifier('then')), [t.arrowFunctionExpression([t.identifier('data')], t.callExpression(t.memberExpression(t.identifier(name), t.identifier('decode')), [t.newExpression(t.memberExpression(t.identifier('_m0'), t.identifier('Reader')), [t.identifier('data')])]))]));
};

var rpcClassMethod = function rpcClassMethod(name, msg, request, response, packageImport) {
  return (0, _utils.classMethod)('method', t.identifier(name), [(0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(request))))], t.blockStatement([// const data = QueryAccountsRequest.encode(request).finish();
  encodeData(request), // const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
  promiseRequest(msg, packageImport), // return promise.then((data) => QueryAccountsResponse.decode(new _m0.Reader(data)));                        
  returnPromise(response)]), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(response))]))));
};

var rpcClassConstructor = function rpcClassConstructor(methods) {
  return (0, _utils.classMethod)('constructor', t.identifier('constructor'), [(0, _utils.identifier)('rpc', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))))], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('rpc')), t.identifier('rpc')))].concat((0, _toConsumableArray2["default"])(methods.map(function (method) {
    return bindThis(method);
  })))));
};

var createRpcClientInterface = function createRpcClientInterface(context, service) {
  var _service$methods;

  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var methods = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {}).map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return rpcMethod(name, method.requestType, method.responseType, [(0, _utils.commentBlock)('')], [(0, _utils.commentBlock)(method.comment)] // trailingComments
    // leadingComments
    );
  });
  var obj = t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(service.name), null, [], t.tsInterfaceBody((0, _toConsumableArray2["default"])(methods))));
  obj.leadingComments = [(0, _utils.commentBlock)("* ".concat(service.name, " defines the RPC service "))];
  return obj;
};

exports.createRpcClientInterface = createRpcClientInterface;

var createRpcClientClass = function createRpcClientClass(context, service) {
  var _service$methods2, _service$methods3;

  context.addUtil('Rpc');
  context.addUtil('_m0');
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var name = service.name + 'ClientImpl';
  var implementsName = service.name;
  var methodNames = Object.keys((_service$methods2 = service.methods) !== null && _service$methods2 !== void 0 ? _service$methods2 : {}).map(function (key) {
    return camelRpcMethods ? (0, _utils2.camel)(key) : key;
  });
  var methods = Object.keys((_service$methods3 = service.methods) !== null && _service$methods3 !== void 0 ? _service$methods3 : {}).map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return rpcClassMethod(name, key, method.requestType, method.responseType, context.ref.proto["package"] + '.' + service.name);
  });
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(t.identifier(name), null, t.classBody([(0, _utils.classProperty)(t.identifier('rpc'), null, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))), null, false, false, true, 'private'), // CONSTRUCTOR
  rpcClassConstructor(methodNames)].concat((0, _toConsumableArray2["default"])(methods))), null, [t.tsExpressionWithTypeArguments(t.identifier(implementsName))]));
};

exports.createRpcClientClass = createRpcClientClass;

var createRpcInterface = function createRpcInterface(context, service) {
  return t.tsInterfaceDeclaration(t.identifier('Rpc'), null, [], t.tsInterfaceBody([t.tsMethodSignature(t.identifier('request'), null, [(0, _utils.identifier)('service', t.tsTypeAnnotation(t.tsStringKeyword())), (0, _utils.identifier)('method', t.tsTypeAnnotation(t.tsStringKeyword())), (0, _utils.identifier)('data', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Uint8Array'))))], t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier('Uint8Array'))]))))]));
};

exports.createRpcInterface = createRpcInterface;